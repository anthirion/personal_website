<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site Antoine</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header id="top">
        <a href="index.html">
            <img id="logo" src="img/index/logo.png" alt="site_logo">
            <nav>
                <a href="index.html#projects">Mes projets</a>
                <a href="index.html#articles">Mes articles</a>
                <a href="index.html#about">A propos</a>
            </nav>
            <a href="https://github.com/corentinckf/projetZ1">
                <img class="github_link" src="img/index/github_dark.jpg" alt="github_link">
            </a>
        </a>
    </header>

    <section>
        <h1>LabyBoule - jeu de labyrinthe</h1>
        <button type="button" class="cta">Tester</button>
    </section>

    <img class="illustration" src="img/index/labyrinth.jpg">

    <article>
        <h2>Présentation et objectifs du projet</h2>
        <p>
            Ce projet consiste à coder un jeu de labyrinthe en C et SDL. Le projet a duré 2 semaines complètes et a été réalisé en équipe. Le principe du jeu consiste à contrôler Pikachu dans un labyrinthe. Plusieurs Pokeball se rapprochent de lui. L'objectif est de faire exploser toutes les Pokeballs en posant une mine. Si Pikachu est touché par une Pokeball, il perd une vie, s'il est touché par 2 Pokeballs, la partie est perdue. <br>
            Les objectifs du projet étaient les suivants :
            <ul>
                <li>Progresser en langage C</li>
                <li>Découvrir la bibliothèque SDL2 pour les rendus graphiques</li>
                <li>Découvrir ou revoir des algorithmes de recherche de chemin</li>
            </ul>
            Après une démonstration du résultat, je présenterai les différentes étapes du projets dans cet ordre: apprentissage de la bibliothèque SDL2, découverte de nouvelles structures de données et développement de parcours de graphes.
        </p>

        <h2>Démonstration</h2>
        <h3>Comportement du jeu en cas de défaite</h3>
        <p>
            La vidéo ci-dessous montre une partie perdue où deux Pokeballs touchent Pikachu avant qu'il ne réussisse à faire sauter toutes les Pokeballs sur une mine.
            <p><video src="videos/jeu_premiere.mp4" controls width="600"></video></p>
        </p>
        <h3>Comportement du jeu en cas de victoire</h3>
        <p>
            La vidéo ci-dessous montre une partie gagnée où Pikachu réussit à faire sauter toutes les Pokeballs sur une mine avant d'être touché deux fois.
            <p><video src="videos/jeu_deuxieme.mp4" controls width="600"></video></p>
        </p>

        <h2>Bibliothèque SDL2</h2>
        <p>
            La SDL (pour Simple DirectMedia Layer) est une bibliothèque logicielle libre, utilisée pour créer des applications multimédias en deux dimensions avec du son comme les jeux vidéo, les démos graphiques, les émulateurs, etc. (extrait de Wikipedia). <br/>
            Cette bibliothèque permet notamment :
            <ul>
                <li>un affichage de rendus dans des fenêtres</li>
                <li>la gestion du son</li>
                <li>la gestion de périphériques tels que la souris, le clavier ou encore le joystick</li>
            </ul>
            Pour plus d'informations au sujet de cette bibliothèque, vous pouvez visiter <a href="https://www.libsdl.org/">leur site</a>
        </p>
        <h3>Dessiner sur un rendu</h3>
        <p>
            La bibliothèque SDL2 permet entre autres de dessiner sur un rendu. Un rendu (ou renderer en anglais) est une zone dans 
            laquelle il sera possible de dessiner ou de poser des images. Grâce à lui, on peut déjà construire quelques animations 
            simples. Pour ma part, j'ai décidé de faire des carrés allant de haut en bas tout en changeant de couleur. Vous pouvez voir
            ci-dessous le résultat :
            <p><video src="videos/Animation_serpents.mp4" controls width="600"></video></p>
        </p>
        <h3>Manipuler des textures</h3>
        <p>
            Après avoir créer des animations simples, on va pouvoir créer des choses plus belles avec des vraies images. Pour cela, on va utiliser des textures. <br/>
            On va pouvoir faire plusieurs choses : ajouter un arrière-plan, incruster une image dans un arrière-plan, ou encore faire bouger un personnage issu d'une planche de sprite. Voici une vidéo montrant quelques animations utilisant des textures : <br />
            <p><video src="videos/textures.mp4" controls width="600"></video></p>
        </p>
        <h3>Un premier jeu : le jeu de la vie</h3>
        <p>
            Pour appliquer les connaissances précédemment acquises, codons le jeu de la vie. Le jeu de la vie est un jeu de simulation de la vie et mort de plusieurs cellules. Les cellules mortes sont représentées en blanc tandis que les cellules vivantes
            sont représentées en noir. Le joueur doit choisir la situation initiale. Si vous ne connaissez pas ce jeu, je vous recommande vivement de regarder <a href="https://www.youtube.com/watch?v=S-W0NX97DB0&t=933s">cette vidéo</a>. <br />
            Ci-dessous mon implémentation du jeu : <br>
            <p><video src="videos/vie.mp4" controls width="600"></video></p>
        </p>

        <h2>Partition</h2>
        <p>
            Maintenant que nous avons appris à maîtriser une bibliothèque graphique qui va nous permettre d'ajouter une interface graphique à notre jeu, on doit implémenter un algorithme de recherche de plus court chemin. Cet algorithme permettra aux Pokeball de suivre Pikachu.
        </p>
        <h3>Présentation</h3>
        <p>
            L'idée derriere la notion de partition est la notion de classification : les éléments d'un ensemble sont regroupés par paquets. Les paquets sont appelés <em>classes</em>.
            D'un point de vue formel, on impose néanmoins quelques restrictions supplémentaires:
            <ul>
                <li>Aucune classe ne doit être vide, autrement dit toute classe doit contenir au moins un élément.</li>
                <li>L'union de toutes les classes doit être égale à l'ensemble entier ce qui signifie que tout élément de
                    l'ensemble doit appartenir à une classe.</li>
                <li>L'intersection entre deux classes est vide, autrement dit un élément appartient à au plus une classe.</li>
            </ul>
        </p>
        <h3>Implémentation</h3>
        <p>
            Il existe deux types d'implementation pour ce type de structure :
            <ul>
                <li>l'implémentation par marqueurs</li>
                <li>l'implémentation arborescente</li>
            </ul>
            L'implémentation par marqueurs consiste à gérer un tableau des classes. Je ne m'attarderai pas sur cette implémentation, j'expliquerai plus en détails l'implémentation arborescente. Dans cette dernière implémentation, on représente la partition par une forêt, chaque arbre représentant une classe. Les noeuds de l'arbre sont les éléments de la classe et la racine est l'étiquette de la classe. Les graphes ont été dessinés avec l'outil <em>Graphviz</em>.
        </p>
        <h3>Composantes connexes</h3>
        <p>
            Un graphe non orienté est connexe s'il existe toujours un chemin reliant deux nœuds quelconques du graphe. Les composantes connexes d'un graphe est l'ensemble contenant les sous-graphes connexes maximaux au sens de l'inclusion.
            <p><img src="img/labyrinth/graph_example.png" alt="exemple de graphe"></p>
            Ce graphe possède 4 composantes connexes :
            <p><table>
                <tr>
                    <td><img src="img/labyrinth/graph_cc1.png" alt="composante connexe"></td>
                    <td><img src="img/labyrinth/graph_cc2.png" alt="composante connexe"></td>
                    <td><img src="img/labyrinth/graph_cc3.png" alt="composante connexe"></td>
                    <td><img src="img/labyrinth/graph_cc4.png" alt="composante connexe"></td>
                </tr>
            </table>
            </p>
            On veut réaliser un algorithme qui puisse nous déterminer les composantes connexes d'un graphe donné en entrée. Pour cela on va utiliser le type de données partition décrit plus haut. On va procéder de la manière suivante :
            <ul>
                <li>Créer une partition dont les éléments sont les nœuds,</li>
                <li>Pour chaque arête du graphe, fusionner dans la partition des classes contenant les extrémités de l'arête  (ne rien faire s'ils sont déjà dans la même classe),</li>
            </ul>
        </p>
        <h3>Arbre couvrant de poids minimal et algorithme de Kruskal</h3>
        <p>
            Un <em>arbre</em> est un graphe connexe et sans cycle, ce qui revient à dire que pour deux sommets d'un arbre, il n'existe qu'un seul chemin les reliant. Un <em>arbre couvrant</em> d'un graphe est un arbre qui vérifie que :
            <ul>
                <li>ses nœuds sont les mêmes que ceux du graphe,</li>
                <li>la liste de ses arêtes est extraite de la liste des arêtes du graphe.</li>
            </ul>
            Sur un graphe non orienté valué (ie que ses arêtes possèdent un poids), un arbre couvrant est de poids minimal si la somme des valuations de ses arêtes est minimale. <br/>
            Pour déterminer un arbre couvrant est de poids minimal, on va utiliser l'algorithme de Kruskal en se servant du type partition. Pour l'algorithme de Kruskal, on effectue les étapes suivantes :
            <ol>
                <li>Ordonner par ordre croissant de valuation les arêtes (cette étape peut être omise si on ne cherche pas un arbre couvrant de poids minimal),</li>
                <li>Créer une partition dont les éléments sont les nœuds du graphe,</li>
                <li>Créer une liste d'arêtes A, vide,</li>
                <li>Pour chaque arête, si les deux extrémités de l'arête ne sont pas dans la même composante connexe, alors, fusionner les classes auxquelles elles appartiennent et ajouter cette arête à A.</li>
            </ol>
            Après ces opérations, A contient les arêtes d'un arbre couvrant du graphe, et si le point 1 a été réalisé, celui-ci est  de poids minimal.
            <em>Remarque : dans le cas où le graphe de départ n'est pas connexe, l'algorithme fonctionne et renvoie alors une forêt couvrante de poids minimal.</em>
        </p>
        <h3>Réalisation du labyrinthe</h3>
        <p>
            On cherche à construire un labyrinthe qu'on va implémenté sous forme de graphe. Pour ce faire, on va au préalable mélanger l'ordre des arêtes du graphe (pour ne pas avoir quelque chose de trop ordonné) avant de lui appliquer l'algorithme de Kruskal.
        </p>
        <h3>Visualisation du labyrinthe</h3>
        <p>
            Après tout ce travail, on va enfin pouvoir visualiser notre labyrinthe grâce à la SDL2. Voici le résultat :
            <img src="img/labyrinth/labyrinthe_resizeimage.jpg" alt="labyrinthe" class="centrer">
            <p class="legend">Un exemple de labyrinthe</p>
        </p>
        
        <h2>Conclusion</h2>
        <p>
            Ce projet a permis à mon équipe et à moi d'améliorer mes compétences en C et de découvrir la bibliothèque SDL pour l'affichage graphique. En ajoutant les connaissances sur les graphes et l'implémentation d'algorithmes de recherche de chemin, tout ce travail nous a permis d'implémenter un petit jeu sur le thème du labyrinthe.
        </p>
    </article>

    <!-- To the top button -->
    <a href="#top">
        <img src="img/index/to_the_top.png" alt="to_the_top_button" id="to_the_top_button">
    </a>
</body>
</html>